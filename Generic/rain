#!/usr/local/bash5/bin/bash

# Original code by seehrum (https://www.reddit.com/r/bash/comments/1cj3xee/rainsh_raining_in_the_linux_terminal/)

# Color codes for raindrops:
# '31' - Red, '32' - Green, '33' - Yellow, '34' - Blue, '35' - Purple, '36' - Cyan, '37' - White

# Function to display help information
show_help() {
    echo "Usage: raindrop-script [options]"
    echo -e "\nOptions:"
    echo "  -d, --density=DENSITY           Set the density of the raindrops. (Default: 2)"
    echo -e "                                      Examples: -d 5, --density=3\n"
    echo "  -c, --char=CHARACTER            Character to use as raindrops. (Default: 'ðŸ’§')"
    echo -e "                                      Examples: -c @, --char='*'\n"
    echo "  --color-code=COLOR, -k=COLOR    ANSI color code for the raindrop. (Default: 35 for purple)"
    echo -e "                                      Examples: -k 32, --color-code=36\n"
    echo "  -s, --speed=SPEED               Speed of the raindrops. Values: 1 (slowest) to 5 (fastest). (Default: 2)"
    echo -e "                                      Examples: -s 4, --speed=3\n"
    echo "  -r, --randomize                 Enable randomization of speed and density every 15 seconds."
    echo -e "                                      By default, randomization is off.\n"
    echo "  -h, --help                      Display this help message and exit.\n"
    read -n 1 -s -r -p "Press any key to exit..."
}

# Initializes terminal settings: clears the screen, hides the cursor, 
# disables input echoing, and captures terminal dimensions.
initialize_screen() {
    clear
    tput civis  # Hide cursor
    stty -echo  # Disable input echoing
    update_dimensions # Get initial dimensions
}

# Function to update terminal dimensions upon resize.
update_dimensions() {
    # Store old dimensions for comparison
    local old_width=$width
    local old_height=$height
    
    # Add a short delay to let terminal stabilize after resize
    sleep 0.2
    
    # Get the potentially new terminal dimensions.
    height=$(tput lines)
    width=$(tput cols)
    
    # Complete terminal reset and cleanup
    printf "\033[2J"     # Clear entire screen
    printf "\033[3J"     # Clear scrollback buffer
    printf "\033[H"      # Move cursor to home position
    
    # Force a full tput reset of the terminal
    tput reset
    tput civis           # Hide cursor again after reset
    
    # Completely clear the raindrops array after a resize
    raindrops=()
    
    # Set a flag to indicate we're in a post-resize stabilization period
    resize_stabilizing=true
    stabilization_counter=0
}

# Declare an associative array to track the position and speed of raindrops.
declare -A raindrops

# Places raindrops on random columns with random speeds, based on the density.
place_raindrop() {
    local chars=("$rain_char")  # Treats rain_char as an array to support multiple characters
    # Ensure width is at least 1 to avoid modulo by zero if terminal is rapidly squashed
    local current_width=${width:-1} 
    [[ $current_width -lt 1 ]] && current_width=1 

    for ((i=0; i<density; i++)); do
        for ch in "${chars[@]}"; do
            # Use the potentially updated width for placement
            local x=$((RANDOM % current_width))  
            local speed=$((RANDOM % speed_range + 1)) 
            raindrops["$x,0,$ch"]=$speed  
        done
    done
}

# Moves the raindrops down by their respective speeds and erases them once off-screen.
move_raindrops() {
    declare -A new_positions  # Temporary array to hold updated positions
    local buffer=""
    # Ensure height is valid
    local current_height=${height:-1}
    [[ $current_height -lt 1 ]] && current_height=1
    # Ensure width is valid
    local current_width=${width:-1}
    [[ $current_width -lt 1 ]] && current_width=1

    for pos in "${!raindrops[@]}"; do
        # Check if the key still exists before processing
        [[ -v raindrops["$pos"] ]] || continue 

        IFS=',' read -r x y ch <<< "$pos"  # Extract x, y, and character
        # Ensure we have a valid speed value before proceeding
        local speed=${raindrops[$pos]}
        [[ -z "$speed" ]] && continue # Skip if speed is somehow missing
        
        # Skip raindrops that are outside the terminal width
        [[ $x -ge $current_width ]] && continue

        local newY=$((y + speed))  # Calculate new y position
        
        # Check if old position y is valid before attempting to clear
        if [[ "$y" =~ ^[0-9]+$ ]] && [ "$y" -ge 0 ]; then
             buffer+="\e[${y};${x}H "  # Clear the old position
        fi

        # Use the potentially updated height for bounds check
        if [ $newY -lt $current_height ]; then  
            buffer+="\e[${newY};${x}H\e[${color}m${ch}\e[0m"  # Move raindrop to new position
            new_positions["$x,$newY,$ch"]=$speed  # Store new position and speed
        fi # Else: drop is off-screen, don't add to new_positions or buffer
    done

    # Safely update raindrops array
    raindrops=()  # Clear old raindrops safely
    for k in "${!new_positions[@]}"; do
         # Check if speed value exists before assigning
        local speed_val=${new_positions["$k"]}
        [[ -n "$speed_val" ]] && raindrops["$k"]=$speed_val
    done

    # Print the buffer only if it's not empty
    [[ -n "$buffer" ]] && echo -ne "$buffer"
}

# Resets terminal settings to normal on exit (shows cursor, enables input echoing).
cleanup() {
    tput cnorm  # Show cursor again
    stty echo  # Re-enable input echoing
    clear
    exit 0
}

# Trap signals to ensure cleanup is called on exit or script interruption.
# Also trap SIGWINCH to handle terminal resizing.
trap cleanup SIGINT SIGTERM EXIT
trap update_dimensions SIGWINCH

# Randomizes density and speed every 15 seconds if randomization is enabled.
randomize_vars() {
    if [[ "$randomize" == "true" ]]; then
        while true; do
            density=$((RANDOM % 10 + 1))  # Randomize density between 1 and 10
            speed_range=$((RANDOM % 5 + 1))  # Randomize speed between 1 and 5
            sleep 15  # Wait 15 seconds before next randomization
        done
    fi
}

# Set default values for parameters.
density=2
rain_char='ðŸ’§'
color=35
speed_range=2
randomize=false

# Parse command-line arguments and flags.
while [[ $# -gt 0 ]]; do
    case "$1" in
        -d=*|--density=*)  # Handle --density=VALUE or -d=VALUE
            density="${1#*=}"
            shift
            ;;
        -d|--density)  # Handle --density VALUE or -d VALUE
            density="$2"
            shift 2
            ;;
        -c=*|--char=*)  # Handle --char=VALUE or -c=VALUE
            rain_char="${1#*=}"
            shift
            ;;
        -c|--char)  # Handle --char VALUE or -c VALUE
            rain_char="$2"
            shift 2
            ;;
        --color-code=*|-k=*)  # Handle --color-code=VALUE or -k=VALUE
            color="${1#*=}"
            shift
            ;;
        --color-code|-k)  # Handle --color-code VALUE or -k VALUE
            color="$2"
            shift 2
            ;;
        -s=*|--speed=*)  # Handle --speed=VALUE or -s=VALUE
            speed_range="${1#*=}"
            shift
            ;;
        -s|--speed)  # Handle --speed VALUE or -s VALUE
            speed_range="$2"
            shift 2
            ;;
        -r|--randomize)  # Handle --randomize or -r without an argument
            randomize=true
            shift
            ;;
        -h|--help)  # Display help message and exit
            show_help
            exit 0
            ;;
        *)  # Handle invalid options
            echo "Error: Invalid option '$1'"
            show_help
            exit 1
            ;;
    esac
done

# Initialize the screen (clear, hide cursor, disable echo).
initialize_screen

# If randomization is enabled, run the randomize_vars function in the background.
randomize_vars &

# Add to main loop:
resize_stabilizing=false
stabilization_counter=0

# Main loop for animation: place and move raindrops, check for 'q' key to quit.
while true; do
    read -s -n 1 -t 0.01 key  # Read keyboard input non-blocking
    if [[ $key == "q" ]]; then  # Exit if 'q' is pressed
        cleanup
    fi
    
    # Use copies of potentially volatile width/height for this frame
    frame_width=$width
    frame_height=$height

    # Add safety checks before calling functions dependent on dimensions
    if [[ "$frame_width" -gt 0 && "$frame_height" -gt 0 ]]; then
        if [[ "$resize_stabilizing" == true ]]; then
            ((stabilization_counter++))
            if [[ $stabilization_counter -ge 10 ]]; then  # Increased from 5 to 10 iterations
                resize_stabilizing=false
                stabilization_counter=0
                # Do one final clear to ensure a clean start
                printf "\033[2J\033[H"
            else
                # Skip drawing during stabilization period
                sleep 0.05  # Increased from 0.03 to 0.05
                continue
            fi
        fi
        place_raindrop  # Place new raindrops using current width
        move_raindrops  # Move existing raindrops using current height
    fi
    
    sleep 0.01  # Small delay to control animation speed
done
