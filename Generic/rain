#!/usr/local/bash5/bin/bash

# Original code by seehrum (https://www.reddit.com/r/bash/comments/1cj3xee/rainsh_raining_in_the_linux_terminal/)

# Color codes for raindrops:
# '31' - Red, '32' - Green, '33' - Yellow, '34' - Blue, '35' - Purple, '36' - Cyan, '37' - White

# Function to display help information
show_help() {
    echo "Usage: raindrop-script [options]"
    echo -e "\nOptions:"
    echo "  -d, --density=DENSITY           Set the density of the raindrops. (Default: 2)"
    echo -e "                                      Examples: -d 5, --density=3\n"
    echo "  -c, --char=CHARACTER            Character to use as raindrops. (Default: 'ðŸ’§')"
    echo -e "                                      Examples: -c @, --char='*'\n"
    echo "  --color-code=COLOR, -k=COLOR    ANSI color code for the raindrop. (Default: 35 for purple)"
    echo -e "                                      Examples: -k 32, --color-code=36\n"
    echo "  -s, --speed=SPEED               Speed of the raindrops. Values: 1 (slowest) to 5 (fastest). (Default: 3)"
    echo -e "                                      Examples: -s 4, --speed=2\n"
    echo "  -w, --wind=WIND                 Wind strength. Values: 1 (no wind) to 5 (strong wind). (Default: 1)"
    echo -e "                                      Examples: -w 3, --wind=5\n"
    echo "  -wd, --wind-dir=DIRECTION       Wind direction. Values: left, right, rand. (Default: right)"
    echo -e "                                      Examples: -wd left, --wind-dir=rand\n"
    echo "  -r, --randomize                 Enable randomization of speed, density, and wind direction every 15 seconds."
    echo -e "                                      By default, randomization is off.\n"
    echo "  -h, --help                      Display this help message and exit.\n"
    read -n 1 -s -r -p "Press any key to exit..."
}

# Add near the top with other global variables
last_resize_time=0
resize_debounce_delay=0.2  # Seconds to wait after last resize before processing
resize_pending=false       # Initialize to false so we don't delay startup

# Wind management variables
current_wind_direction=1   # 1 for right, -1 for left
current_wind_strength=0    # Current effective wind strength (may differ from wind_strength during lulls)
next_wind_dir_change=0     # Timestamp for next wind direction change
next_wind_lull=0           # Timestamp for next wind lull
wind_lull_end=0            # Timestamp for when current lull ends
wind_transitioning=false   # Flag for transitioning wind strength
target_wind_strength=0     # Target wind strength during transitions
transition_step=0          # Step size for wind strength transitions

# Add these near the top with other global variables
wind_update_counter=0  # Counter for wind updates
dir_update_counter=0   # Counter for direction updates
loop_counter=0         # Main loop counter

# Initialize the screen (clear, hide cursor, disable echo).
initialize_screen() {
    clear
    tput civis  # Hide cursor
    stty -echo  # Disable input echoing
    
    # Get dimensions directly instead of through update_dimensions
    height=$(tput lines)
    width=$(tput cols)
    
    # Ensure we're not in resize pending mode at startup
    resize_pending=false
    
    # Initialize wind variables
    current_wind_strength=$wind_strength
    if [[ "$wind_dir" == "left" ]]; then
        current_wind_direction=-1
    elif [[ "$wind_dir" == "right" ]]; then
        current_wind_direction=1
    else # rand
        # Random initial direction
        if (( RANDOM % 2 == 0 )); then
            current_wind_direction=1
        else
            current_wind_direction=-1
        fi
    fi
    
    # Set initial change times
    next_wind_dir_change=$(($(date +%s) + 8 + RANDOM % 13))  # 8-20 seconds for first change
    next_wind_lull=$(($(date +%s) + 15 + RANDOM % 16))      # 15-30 seconds for first lull
}

# Replace the current update_dimensions function
update_dimensions() {
    # Record the current time
    last_resize_time=$(date +%s.%N)
    
    # Set a flag that we're in resize mode but don't process yet
    resize_pending=true
}

# Add a new function to handle the actual resize processing
process_resize() {
    # Get the new terminal dimensions
    height=$(tput lines)
    width=$(tput cols)
    
    # Complete terminal reset and cleanup
    printf "\033[2J"     # Clear entire screen
    printf "\033[3J"     # Clear scrollback buffer
    printf "\033[H"      # Move cursor to home position
    
    # Force a full tput reset of the terminal
    tput reset
    tput civis           # Hide cursor again after reset
    
    # Completely clear the raindrops array after a resize
    raindrops=()
    
    # Set a flag to indicate we're in a post-resize stabilization period
    resize_stabilizing=true
    stabilization_counter=0
    
    # Force a redraw of the entire visible area to clear any artifacts
    clear_entire_screen
    
    # Reset the pending flag
    resize_pending=false
}

# New function to clear the entire visible area
clear_entire_screen() {
    local clear_buffer=""
    local current_height=${height:-24}  # Default if not set
    local current_width=${width:-80}    # Default if not set
    
    # Generate a buffer to clear every cell on screen
    for ((y=1; y<=current_height; y++)); do
        clear_buffer+="\e[${y};1H"
        for ((x=1; x<=current_width; x++)); do
            clear_buffer+=" "
        done
    done
    
    # Reset cursor to home
    clear_buffer+="\e[H"
    
    # Apply all at once
    echo -ne "$clear_buffer"
}

# Convert speed setting to actual movement amount
get_drop_speed() {
    local setting=$1
    local actual_speed
    
    case $setting in
        1) actual_speed=1 ;;      # Very slow (unchanged)
        2) actual_speed=2 ;;      # Slow (unchanged)
        3) actual_speed=3 ;;      # Medium (unchanged)
        4) actual_speed=5 ;;      # Fast (increased)
        5) actual_speed=7 ;;      # Very fast (increased more)
        *) actual_speed=3 ;;      # Default to medium
    esac
    
    echo $actual_speed
}

# Convert wind strength to actual horizontal movement
get_wind_shift() {
    local setting=$1
    local actual_shift
    
    case $setting in
        0) actual_shift=0 ;;      # No wind (for lulls)
        1) actual_shift=0 ;;      # No wind
        2) actual_shift=1 ;;      # Light wind
        3) actual_shift=2 ;;      # Medium wind
        4) actual_shift=3 ;;      # Strong wind
        5) actual_shift=4 ;;      # Very strong wind
        *) actual_shift=0 ;;      # Default to no wind
    esac
    
    echo $actual_shift
}

# Update wind direction based on time and settings - with less frequent changes
update_wind_direction() {
    # Only run this every 5 frames to reduce overhead
    (( dir_update_counter++ % 5 != 0 )) && return
    
    local current_time=$(date +%s)
    
    # If we're not using random direction, just maintain the fixed direction
    if [[ "$wind_dir" != "rand" ]]; then
        if [[ "$wind_dir" == "left" ]]; then
            current_wind_direction=-1
        else # right
            current_wind_direction=1
        fi
        return
    fi
    
    # Check if it's time to change wind direction
    if (( current_time >= next_wind_dir_change )); then
        # Randomly choose a new direction
        if (( RANDOM % 2 == 0 )); then
            current_wind_direction=1
        else
            current_wind_direction=-1
        fi
        
        # Set next change time (8-20 seconds from now) - LONGER INTERVAL
        next_wind_dir_change=$((current_time + 8 + RANDOM % 13))
    fi
}

# Update wind strength based on time and lull settings - with longer lulls
update_wind_strength() {
    # Only run this every 5 frames to reduce overhead
    (( wind_update_counter++ % 5 != 0 )) && return
    
    local current_time=$(date +%s)
    
    # Only apply lulls if wind is not set to 1 (no wind)
    if [[ "$wind_strength" -gt 1 ]]; then
        # Check if we're in a transition
        if [[ "$wind_transitioning" == "true" ]]; then
            # Simple integer-based transition
            if (( current_wind_strength < target_wind_strength )); then
                (( current_wind_strength++ ))
            elif (( current_wind_strength > target_wind_strength )); then
                (( current_wind_strength-- ))
            fi
            
            # Check if transition is complete
            if (( current_wind_strength == target_wind_strength )); then
                wind_transitioning=false
                
                # If we've reached the target and it was a lull target, set the end time
                if (( target_wind_strength < wind_strength )); then
                    # Lull lasts 3-7 seconds (LONGER LULLS)
                    wind_lull_end=$((current_time + 3 + RANDOM % 5))
                fi
            fi
        # Check if we're in a lull and it's time to end it
        elif (( current_wind_strength < wind_strength && current_time >= wind_lull_end )); then
            # Start transition back to normal wind strength
            wind_transitioning=true
            target_wind_strength=$wind_strength
        # Check if it's time to start a new lull
        elif (( current_time >= next_wind_lull && current_wind_strength == wind_strength )); then
            # Start transitioning to a lull (lower or no wind)
            wind_transitioning=true
            # Either reduce to no wind or lower intensity (randomly chosen)
            if (( RANDOM % 3 == 0 )); then
                target_wind_strength=0  # Complete lull (no wind)
            else
                # Partial lull (reduced wind)
                target_wind_strength=$(( wind_strength / 2 ))
                # Ensure at least some reduction
                if (( target_wind_strength >= wind_strength )); then
                    target_wind_strength=$(( wind_strength - 1 ))
                fi
            fi
            
            # Set next lull time (15-30 seconds from now) - LONGER INTERVAL BETWEEN LULLS
            next_wind_lull=$((current_time + 15 + RANDOM % 16))
        fi
    else
        # For wind_strength=1, ensure current_wind_strength is also 1
        current_wind_strength=1
    fi
}

# Declare an associative array to track the position and speed of raindrops.
declare -A raindrops

# Places raindrops on random columns with random speeds, based on the density.
place_raindrop() {
    local chars=("$rain_char")  # Treats rain_char as an array to support multiple characters
    # Ensure width is at least 1 to avoid modulo by zero if terminal is rapidly squashed
    local current_width=${width:-1} 
    [[ $current_width -lt 1 ]] && current_width=1 

    # Create buffer for new raindrops
    local new_drops_buffer=""
    
    for ((i=0; i<density; i++)); do
        for ch in "${chars[@]}"; do
            # Use the potentially updated width for placement
            local x=$((RANDOM % current_width))
            
            # Get a random speed within the range but use our speed conversion
            local raw_speed=$((RANDOM % speed_range + 1))
            local actual_speed=$(get_drop_speed $raw_speed)
            
            raindrops["$x,0,$ch"]=$actual_speed
            
            # Add new raindrop to buffer with absolute positioning
            new_drops_buffer+="\e[1;${x}H\e[${color}m${ch}\e[0m"
        done
    done
    
    # Output all new raindrops at once
    [[ -n "$new_drops_buffer" ]] && echo -ne "$new_drops_buffer"
}

# Moves the raindrops down by their respective speeds and erases them once off-screen.
move_raindrops() {
    declare -A new_positions  # Temporary array to hold updated positions
    local buffer=""
    # Ensure height is valid
    local current_height=${height:-1}
    [[ $current_height -lt 1 ]] && current_height=1
    # Ensure width is valid
    local current_width=${width:-1}
    [[ $current_width -lt 1 ]] && current_width=1

    # Calculate wind effect for this frame - simplified to use integers only
    local wind_effect=$(($(get_wind_shift $current_wind_strength) * current_wind_direction))

    for pos in "${!raindrops[@]}"; do
        IFS=',' read -r x y ch <<< "$pos"  # Extract x, y, and character
        # Get speed (skip error checking for performance)
        local speed=${raindrops[$pos]}
        
        # Skip raindrops that are outside the terminal boundaries
        [[ $x -ge $current_width || $y -ge $current_height ]] && continue

        # Calculate new positions with faster integer arithmetic
        local newY=$((y + speed))
        local newX=$((x + wind_effect))
        
        # Clear old position
        buffer+="\e[${y};${x}H "

        # Check if raindrop is still on screen
        if (( newY < current_height && newX >= 0 && newX < current_width )); then
            # Draw at new position
            buffer+="\e[${newY};${newX}H\e[${color}m${ch}\e[0m"
            new_positions["$newX,$newY,$ch"]=$speed
        fi
    done

    # Safely update raindrops array with new positions
    raindrops=()  # Clear old raindrops
    for k in "${!new_positions[@]}"; do
        raindrops["$k"]=${new_positions["$k"]}
    done

    # Output all changes at once
    [[ -n "$buffer" ]] && echo -ne "$buffer"
}

# Resets terminal settings to normal on exit (shows cursor, enables input echoing).
cleanup() {
    tput cnorm  # Show cursor again
    stty echo  # Re-enable input echoing
    clear
    exit 0
}

# Trap signals to ensure cleanup is called on exit or script interruption.
# Also trap SIGWINCH to handle terminal resizing.
trap cleanup SIGINT SIGTERM EXIT
trap update_dimensions SIGWINCH

# Randomizes variables every 15 seconds if randomization is enabled.
randomize_vars() {
    if [[ "$randomize" == "true" ]]; then
        while true; do
            density=$((RANDOM % 10 + 1))  # Randomize density between 1 and 10
            speed_range=$((RANDOM % 5 + 1))  # Randomize speed between 1 and 5
            wind_dir="rand"  # Set wind direction to random when randomization is enabled
            sleep 15  # Wait 15 seconds before next randomization
        done
    fi
}

# Set default values for parameters.
density=2
rain_char='ðŸ’§'
color=35
speed_range=3  # Default to medium speed now (changed from 2)
wind_strength=1  # Default to no wind
wind_dir="right"  # Default wind direction is right
randomize=false

# Parse command-line arguments and flags.
while [[ $# -gt 0 ]]; do
    case "$1" in
        -d=*|--density=*)  # Handle --density=VALUE or -d=VALUE
            density="${1#*=}"
            shift
            ;;
        -d|--density)  # Handle --density VALUE or -d VALUE
            density="$2"
            shift 2
            ;;
        -c=*|--char=*)  # Handle --char=VALUE or -c=VALUE
            rain_char="${1#*=}"
            shift
            ;;
        -c|--char)  # Handle --char VALUE or -c VALUE
            rain_char="$2"
            shift 2
            ;;
        --color-code=*|-k=*)  # Handle --color-code=VALUE or -k=VALUE
            color="${1#*=}"
            shift
            ;;
        --color-code|-k)  # Handle --color-code VALUE or -k VALUE
            color="$2"
            shift 2
            ;;
        -s=*|--speed=*)  # Handle --speed=VALUE or -s=VALUE
            speed_range="${1#*=}"
            # Ensure speed_range is within valid bounds
            [[ $speed_range -lt 1 ]] && speed_range=1
            [[ $speed_range -gt 5 ]] && speed_range=5
            shift
            ;;
        -s|--speed)  # Handle --speed VALUE or -s VALUE
            speed_range="$2"
            # Ensure speed_range is within valid bounds
            [[ $speed_range -lt 1 ]] && speed_range=1
            [[ $speed_range -gt 5 ]] && speed_range=5
            shift 2
            ;;
        -w=*|--wind=*)  # Handle --wind=VALUE or -w=VALUE
            wind_strength="${1#*=}"
            # Ensure wind_strength is within valid bounds
            [[ $wind_strength -lt 1 ]] && wind_strength=1
            [[ $wind_strength -gt 5 ]] && wind_strength=5
            shift
            ;;
        -w|--wind)  # Handle --wind VALUE or -w VALUE
            wind_strength="$2"
            # Ensure wind_strength is within valid bounds
            [[ $wind_strength -lt 1 ]] && wind_strength=1
            [[ $wind_strength -gt 5 ]] && wind_strength=5
            shift 2
            ;;
        -wd=*|--wind-dir=*)  # Handle --wind-dir=VALUE or -wd=VALUE
            wind_dir="${1#*=}"
            # Ensure wind_dir is valid
            if [[ "$wind_dir" != "left" && "$wind_dir" != "right" && "$wind_dir" != "rand" ]]; then
                echo "Error: Invalid wind direction. Valid values are 'left', 'right', or 'rand'."
                show_help
                exit 1
            fi
            shift
            ;;
        -wd|--wind-dir)  # Handle --wind-dir VALUE or -wd VALUE
            wind_dir="$2"
            # Ensure wind_dir is valid
            if [[ "$wind_dir" != "left" && "$wind_dir" != "right" && "$wind_dir" != "rand" ]]; then
                echo "Error: Invalid wind direction. Valid values are 'left', 'right', or 'rand'."
                show_help
                exit 1
            fi
            shift 2
            ;;
        -r|--randomize)  # Handle --randomize or -r without an argument
            randomize=true
            wind_dir="rand"  # Set wind direction to random when randomization is enabled
            shift
            ;;
        -h|--help)  # Display help message and exit
            show_help
            exit 0
            ;;
        *)  # Handle invalid options
            echo "Error: Invalid option '$1'"
            show_help
            exit 1
            ;;
    esac
done

# Initialize the screen (clear, hide cursor, disable echo).
initialize_screen

# If randomization is enabled, run the randomize_vars function in the background.
randomize_vars &

# Add to main loop:
resize_stabilizing=false
stabilization_counter=0

# Main loop for animation: place and move raindrops, check for 'q' key to quit.
while true; do
    read -s -n 1 -t 0.001 key  # Read keyboard input non-blocking (very short timeout)
    if [[ $key == "q" ]]; then  # Exit if 'q' is pressed
        cleanup
    fi
    
    # Only update wind metrics occasionally to reduce overhead
    (( loop_counter++ % 3 == 0 )) && {
        update_wind_direction
        update_wind_strength
    }
    
    # Handle resize debouncing
    if [[ "$resize_pending" == "true" ]]; then
        current_time=$(date +%s.%N)
        time_diff=$(echo "$current_time - $last_resize_time" | bc)
        
        # If enough time has passed since the last resize event, process the resize
        if (( $(echo "$time_diff > $resize_debounce_delay" | bc -l) )); then
            process_resize
        else
            # Skip rendering this frame while waiting for resize to settle
            sleep 0.001
            continue
        fi
    fi
    
    # Use copies of potentially volatile width/height for this frame
    frame_width=$width
    frame_height=$height

    # Add safety checks before calling functions dependent on dimensions
    if [[ "$frame_width" -gt 0 && "$frame_height" -gt 0 ]]; then
        if [[ "$resize_stabilizing" == true ]]; then
            ((stabilization_counter++))
            if [[ $stabilization_counter -ge 15 ]]; then
                resize_stabilizing=false
                stabilization_counter=0
                # Do one final clear to ensure a clean start
                clear_entire_screen
            else
                # Skip drawing during stabilization period
                sleep 0.01
                continue
            fi
        fi
        place_raindrop  # Place new raindrops using current width
        move_raindrops  # Move existing raindrops using current height
    fi
    
    # Fixed 10ms delay for smooth animation
    sleep 0.01
done
