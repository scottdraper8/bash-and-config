#!/usr/local/bash5/bin/bash

# Original code by seehrum (https://www.reddit.com/r/bash/comments/1cj3xee/rainsh_raining_in_the_linux_terminal/)

# Color codes for raindrops:
# '31' - Red, '32' - Green, '33' - Yellow, '34' - Blue, '35' - Purple, '36' - Cyan, '37' - White

# Function to display help information
show_help() {
    echo "Usage: raindrop-script [options]"
    echo -e "\nOptions:"
    echo "  -d, --density=DENSITY           Set the density of the raindrops. (Default: 2)"
    echo -e "                                      Examples: -d 5, --density=3\n"
    echo "  -c, --char=CHARACTER            Character to use as raindrops. (Default: 'ðŸ’§')"
    echo -e "                                      Examples: -c @, --char='*'\n"
    echo "  --color-code=COLOR, -k=COLOR    ANSI color code for the raindrop. (Default: 35 for purple)"
    echo -e "                                      Examples: -k 32, --color-code=36\n"
    echo "  -s, --speed=SPEED               Speed of the raindrops. Values: 1 (slowest) to 5 (fastest). (Default: 2)"
    echo -e "                                      Examples: -s 4, --speed=3\n"
    echo "  -r, --randomize                 Enable randomization of speed and density every 15 seconds."
    echo -e "                                      By default, randomization is off.\n"
    echo "  -h, --help                      Display this help message and exit.\n"
    read -n 1 -s -r -p "Press any key to exit..."
}

# Add near the top with other global variables
last_resize_time=0
resize_debounce_delay=0.2  # Seconds to wait after last resize before processing
resize_pending=false       # Initialize to false so we don't delay startup

# Initialize the screen (clear, hide cursor, disable echo).
initialize_screen() {
    clear
    tput civis  # Hide cursor
    stty -echo  # Disable input echoing
    
    # Get dimensions directly instead of through update_dimensions
    height=$(tput lines)
    width=$(tput cols)
    
    # Ensure we're not in resize pending mode at startup
    resize_pending=false
}

# Replace the current update_dimensions function
update_dimensions() {
    # Record the current time
    last_resize_time=$(date +%s.%N)
    
    # Set a flag that we're in resize mode but don't process yet
    resize_pending=true
}

# Add a new function to handle the actual resize processing
process_resize() {
    # Get the new terminal dimensions
    height=$(tput lines)
    width=$(tput cols)
    
    # Complete terminal reset and cleanup
    printf "\033[2J"     # Clear entire screen
    printf "\033[3J"     # Clear scrollback buffer
    printf "\033[H"      # Move cursor to home position
    
    # Force a full tput reset of the terminal
    tput reset
    tput civis           # Hide cursor again after reset
    
    # Completely clear the raindrops array after a resize
    raindrops=()
    
    # Set a flag to indicate we're in a post-resize stabilization period
    resize_stabilizing=true
    stabilization_counter=0
    
    # Force a redraw of the entire visible area to clear any artifacts
    clear_entire_screen
    
    # Reset the pending flag
    resize_pending=false
}

# New function to clear the entire visible area
clear_entire_screen() {
    local clear_buffer=""
    local current_height=${height:-24}  # Default if not set
    local current_width=${width:-80}    # Default if not set
    
    # Generate a buffer to clear every cell on screen
    for ((y=1; y<=current_height; y++)); do
        clear_buffer+="\e[${y};1H"
        for ((x=1; x<=current_width; x++)); do
            clear_buffer+=" "
        done
    done
    
    # Reset cursor to home
    clear_buffer+="\e[H"
    
    # Apply all at once
    echo -ne "$clear_buffer"
}

# Declare an associative array to track the position and speed of raindrops.
declare -A raindrops

# Places raindrops on random columns with random speeds, based on the density.
place_raindrop() {
    local chars=("$rain_char")  # Treats rain_char as an array to support multiple characters
    # Ensure width is at least 1 to avoid modulo by zero if terminal is rapidly squashed
    local current_width=${width:-1} 
    [[ $current_width -lt 1 ]] && current_width=1 

    # Create buffer for new raindrops
    local new_drops_buffer=""
    
    for ((i=0; i<density; i++)); do
        for ch in "${chars[@]}"; do
            # Use the potentially updated width for placement
            local x=$((RANDOM % current_width))  
            local speed=$((RANDOM % speed_range + 1)) 
            raindrops["$x,0,$ch"]=$speed
            
            # Add new raindrop to buffer with absolute positioning
            new_drops_buffer+="\e[1;${x}H\e[${color}m${ch}\e[0m"
        done
    done
    
    # Output all new raindrops at once
    [[ -n "$new_drops_buffer" ]] && echo -ne "$new_drops_buffer"
}

# Moves the raindrops down by their respective speeds and erases them once off-screen.
move_raindrops() {
    declare -A new_positions  # Temporary array to hold updated positions
    local buffer=""
    # Ensure height is valid
    local current_height=${height:-1}
    [[ $current_height -lt 1 ]] && current_height=1
    # Ensure width is valid
    local current_width=${width:-1}
    [[ $current_width -lt 1 ]] && current_width=1

    for pos in "${!raindrops[@]}"; do
        # Check if the key still exists before processing
        [[ -v raindrops["$pos"] ]] || continue 

        IFS=',' read -r x y ch <<< "$pos"  # Extract x, y, and character
        # Ensure we have a valid speed value before proceeding
        local speed=${raindrops[$pos]}
        [[ -z "$speed" ]] && continue # Skip if speed is somehow missing
        
        # Skip raindrops that are outside the terminal width or height
        [[ $x -ge $current_width || $y -ge $current_height ]] && continue

        local newY=$((y + speed))  # Calculate new y position
        
        # Always use absolute positioning for clearing old position
        if [[ "$y" =~ ^[0-9]+$ ]] && [ "$y" -ge 0 ] && [ "$y" -lt $current_height ]; then
             buffer+="\e[${y};${x}H " # Clear old position with absolute positioning
        fi

        # Use the potentially updated height for bounds check
        if [ $newY -lt $current_height ]; then  
            # Use absolute positioning for new position
            buffer+="\e[${newY};${x}H\e[${color}m${ch}\e[0m"
            new_positions["$x,$newY,$ch"]=$speed  # Store new position and speed
        fi # Else: drop is off-screen, don't add to new_positions or buffer
    done

    # Safely update raindrops array
    raindrops=()  # Clear old raindrops safely
    for k in "${!new_positions[@]}"; do
         # Check if speed value exists before assigning
        local speed_val=${new_positions["$k"]}
        [[ -n "$speed_val" ]] && raindrops["$k"]=$speed_val
    done

    # Print the buffer only if it's not empty - all position updates at once
    [[ -n "$buffer" ]] && echo -ne "$buffer"
}

# Resets terminal settings to normal on exit (shows cursor, enables input echoing).
cleanup() {
    tput cnorm  # Show cursor again
    stty echo  # Re-enable input echoing
    clear
    exit 0
}

# Trap signals to ensure cleanup is called on exit or script interruption.
# Also trap SIGWINCH to handle terminal resizing.
trap cleanup SIGINT SIGTERM EXIT
trap update_dimensions SIGWINCH

# Randomizes density and speed every 15 seconds if randomization is enabled.
randomize_vars() {
    if [[ "$randomize" == "true" ]]; then
        while true; do
            density=$((RANDOM % 10 + 1))  # Randomize density between 1 and 10
            speed_range=$((RANDOM % 5 + 1))  # Randomize speed between 1 and 5
            sleep 15  # Wait 15 seconds before next randomization
        done
    fi
}

# Set default values for parameters.
density=2
rain_char='ðŸ’§'
color=35
speed_range=2
randomize=false

# Parse command-line arguments and flags.
while [[ $# -gt 0 ]]; do
    case "$1" in
        -d=*|--density=*)  # Handle --density=VALUE or -d=VALUE
            density="${1#*=}"
            shift
            ;;
        -d|--density)  # Handle --density VALUE or -d VALUE
            density="$2"
            shift 2
            ;;
        -c=*|--char=*)  # Handle --char=VALUE or -c=VALUE
            rain_char="${1#*=}"
            shift
            ;;
        -c|--char)  # Handle --char VALUE or -c VALUE
            rain_char="$2"
            shift 2
            ;;
        --color-code=*|-k=*)  # Handle --color-code=VALUE or -k=VALUE
            color="${1#*=}"
            shift
            ;;
        --color-code|-k)  # Handle --color-code VALUE or -k VALUE
            color="$2"
            shift 2
            ;;
        -s=*|--speed=*)  # Handle --speed=VALUE or -s=VALUE
            speed_range="${1#*=}"
            shift
            ;;
        -s|--speed)  # Handle --speed VALUE or -s VALUE
            speed_range="$2"
            shift 2
            ;;
        -r|--randomize)  # Handle --randomize or -r without an argument
            randomize=true
            shift
            ;;
        -h|--help)  # Display help message and exit
            show_help
            exit 0
            ;;
        *)  # Handle invalid options
            echo "Error: Invalid option '$1'"
            show_help
            exit 1
            ;;
    esac
done

# Initialize the screen (clear, hide cursor, disable echo).
initialize_screen

# If randomization is enabled, run the randomize_vars function in the background.
randomize_vars &

# Add to main loop:
resize_stabilizing=false
stabilization_counter=0

# Main loop for animation: place and move raindrops, check for 'q' key to quit.
while true; do
    read -s -n 1 -t 0.001 key  # Read keyboard input non-blocking (very short timeout)
    if [[ $key == "q" ]]; then  # Exit if 'q' is pressed
        cleanup
    fi
    
    # Handle resize debouncing
    if [[ "$resize_pending" == "true" ]]; then
        current_time=$(date +%s.%N)
        time_diff=$(echo "$current_time - $last_resize_time" | bc)
        
        # If enough time has passed since the last resize event, process the resize
        if (( $(echo "$time_diff > $resize_debounce_delay" | bc -l) )); then
            process_resize
        else
            # Skip rendering this frame while waiting for resize to settle
            sleep 0.001
            continue
        fi
    fi
    
    # Use copies of potentially volatile width/height for this frame
    frame_width=$width
    frame_height=$height

    # Add safety checks before calling functions dependent on dimensions
    if [[ "$frame_width" -gt 0 && "$frame_height" -gt 0 ]]; then
        if [[ "$resize_stabilizing" == true ]]; then
            ((stabilization_counter++))
            if [[ $stabilization_counter -ge 15 ]]; then
                resize_stabilizing=false
                stabilization_counter=0
                # Do one final clear to ensure a clean start
                clear_entire_screen
            else
                # Skip drawing during stabilization period
                sleep 0.01
                continue
            fi
        fi
        place_raindrop  # Place new raindrops using current width
        move_raindrops  # Move existing raindrops using current height
    fi
    
    # Fixed 10ms delay for smooth animation
    sleep 0.01
done
