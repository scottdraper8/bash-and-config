#!/usr/local/bash5/bin/bash

#===============================
# CONFIGURATION
#===============================

# Application constants
readonly AWS_TARGET="<your-instance-id>"
readonly AWS_HOST="<your-redshift-host>"
readonly PORT="5439"
readonly DBEAVER_PATH="/Applications/DBeaver.app/Contents/MacOS/dbeaver"

# Maps message types to their display properties
readonly COLOR_CODES=(
    ["status"]="PURPLE"
    ["success"]="GREEN"
    ["error"]="RED"
    ["warning"]="YELLOW"
    ["exit"]="YELLOW"
)

declare -A COLORS=(
    ["RED"]='\033[0;31m'
    ["GREEN"]='\033[0;32m'
    ["BLUE"]='\033[0;34m'
    ["PURPLE"]='\033[0;35m'
    ["YELLOW"]='\033[1;33m'
    ["BOLD"]='\033[1m'
    ["NC"]='\033[0m'
)

declare -A EMOJI=(
    ["status"]="‚ÑπÔ∏è "
    ["success"]="‚úÖ"
    ["error"]="‚ùå"
    ["warning"]="‚ú®"
    ["exit"]="‚ùé"
)

#===============================
# UTILITY FUNCTIONS
#===============================

# Prints formatted messages with color and emoji based on message type
print_message() {
    local type=$1
    local message=$2
    local color="${COLORS[${COLOR_CODES[$type]:-PURPLE}]}"
    printf "${color}${EMOJI[$type]:-} %b${COLORS[NC]}\n" "$message"
    [ "$type" = "error" ] && return 1
}

# Prints section headers with consistent formatting
print_header() {
    echo -e "\n${COLORS[BOLD]}$1${COLORS[NC]}"
    echo "----------------------------------------"
}

#===============================
# PROCESS MANAGEMENT
#===============================

# Checks if the specified port is in use and returns the PID
check_port() {
    lsof -ti:$PORT 2>/dev/null
}

# Terminates a process, with optional force flag for SIGKILL
kill_process() {
    local pid=$1
    local force=${2:-false}
    
    if [[ "$force" == true ]]; then
        kill -9 $pid >/dev/null 2>&1
    else
        kill $pid >/dev/null 2>&1
    fi
}

# Manages process lifecycle (check existence, terminate)
manage_process() {
    local action=$1
    local pid=$2
    local name=$3
    
    case $action in
        "check")
            kill -0 $pid 2>/dev/null
            return $?
            ;;
        "terminate")
            if manage_process check $pid; then
                kill_process $pid
                print_message success "$name (PID: $pid) terminated"
            else
                print_message warning "$name (PID: $pid) already terminated"
            fi
            ;;
    esac
}

# Performs cleanup of all processes and resources on exit
cleanup() {
    print_header "üóëÔ∏è  CLEANUP"
    
    manage_process terminate $DBEAVER_PID "DBeaver"
    manage_process terminate $SSM_PID "AWS SSM session"
    
    local PORT_PID=$(check_port)
    if [ ! -z "$PORT_PID" ]; then
        kill_process $PORT_PID true
        print_message success "Forced release of port $PORT"
    fi
    
    [ -p "$PIPE" ] && rm -f "$PIPE" 2>/dev/null
    print_message success "Cleanup complete"
    exit 0
}

#===============================
# AWS SSM SESSION HANDLING
#===============================

# Generates the JSON parameters for AWS SSM session
get_ssm_parameters() {
    cat <<EOF
{
    "host":["$AWS_HOST"],
    "portNumber":["$PORT"],
    "localPortNumber":["$PORT"]
}
EOF
}

# Processes and formats SSM session output messages
handle_ssm_output() {
    local line=$1
    case "$line" in
        *"Starting session"*)
            print_message status "Session starting: Starting session with SessionId: ${line#*: }"
            ;;
        *"Port"* | *"Command"*)
            [[ ! "$line" =~ "died with" ]] && print_message status "Port configuration: ${line}"
            ;;
        *"Waiting for connections"*)
            print_message status "Awaiting connections..."
            ;;
        *"Connection accepted"*)
            echo ""
            print_message success "Connection established"
            print_message exit "Press Ctrl+C to exit"
            ;;
    esac
}

# Initiates AWS SSM port forwarding session
start_ssm_session() {
    PIPE=$(mktemp -u)
    mkfifo $PIPE
    
    (aws ssm start-session \
        --target $AWS_TARGET \
        --profile default \
        --document-name AWS-StartPortForwardingSessionToRemoteHost \
        --parameters "$(get_ssm_parameters)" 2>/dev/null | \
    while read line; do
        handle_ssm_output "$line"
    done) &
    
    SSM_PID=$!
    print_message success "AWS SSM session started (PID: $SSM_PID)"
}

#===============================
# MAIN EXECUTION
#===============================

# Launches DBeaver database client
launch_dbeaver() {
    print_message status "Launching DBeaver..."
    "$DBEAVER_PATH" >/dev/null 2>&1 &
    DBEAVER_PID=$!
    print_message success "DBeaver launched (PID: $DBEAVER_PID)"
}

# Displays active process information
show_process_info() {
    print_header "üîç PROCESS MONITORING"
    print_message status "Monitoring active processes:"
    print_message status "‚Ä¢ AWS SSM Session (PID: $SSM_PID)"
    print_message status "‚Ä¢ DBeaver Client (PID: $DBEAVER_PID)"
}

# Main script execution
main() {
    clear
    trap cleanup SIGINT SIGTERM
    
    print_header "üåê AWS SSM CONNECTION"
    print_message status "Starting AWS SSM port forwarding session..."
    start_ssm_session
    
    print_header "ü¶´  DATABASE CLIENT"
    launch_dbeaver
    show_process_info
    
    wait -n $SSM_PID $DBEAVER_PID
    cleanup
}

main